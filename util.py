import numpy as np
import networkx as nx
import matplotlib.pyplot as plt

from itertools import combinations


def hypergraph_pcm(
    H1: np.ndarray, H2: np.ndarray, reordered: bool = True
) -> tuple[np.ndarray, np.ndarray]:
    r1, n1 = H1.shape
    r2, n2 = H2.shape

    HX_left = np.kron(H1, np.eye(n2))
    HX_right = np.kron(np.eye(r1), H2.T)
    HX = np.append(HX_left, HX_right, axis=1)

    HZ_left = np.kron(np.eye(n1), H2)
    HZ_right = np.kron(H1.T, np.eye(r2))
    HZ = np.append(HZ_left, HZ_right, axis=1)

    if reordered:
        HX_left_split = np.split(HX_left, n1, axis=1)
        HX_right_split = np.split(HX_right, r1, axis=1)
        HX_split = []
        for i in range(n1):
            HX_split.append(HX_left_split[i])
            if i < r1:
                HX_split.append(HX_right_split[i])
        HX = np.concatenate(tuple(HX_split), axis=1)

        HZ_left_split = np.split(HZ_left, n1, axis=1)
        HZ_right_split = np.split(HZ_right, r1, axis=1)
        HZ_split = []
        for i in range(n1):
            HZ_split.append(HZ_left_split[i])
            if i < r1:
                HZ_split.append(HZ_right_split[i])
        HZ = np.concatenate(tuple(HZ_split), axis=1)

    return HX.astype(int), HZ.astype(int)


def construct_graph(HX: np.ndarray, HZ: np.ndarray) -> nx.Graph:
    """Assumes `HX` and `HZ` are reordered as generated by the `hypergraph_pcm` function."""

    num_data_qubits = HZ.shape[1]
    num_z_checks = HZ.shape[0]
    num_x_checks = HX.shape[0]

    adjacency_matrix = np.block(
        [
            [np.zeros((num_data_qubits, num_data_qubits)), HZ.T, HX.T],
            [HZ, np.zeros((num_z_checks, num_z_checks)), np.zeros((num_z_checks, num_x_checks))],
            [HX, np.zeros((num_x_checks, num_z_checks)), np.zeros((num_x_checks, num_x_checks))],
        ]
    ).astype(int)

    G = nx.from_numpy_array(adjacency_matrix)
    labels = {}
    for i in range(num_data_qubits):
        labels[i] = f"$q_{{{i + 1}}}$"
    for i in range(num_data_qubits, num_data_qubits + num_z_checks):
        labels[i] = f"$Z_{{{i - num_data_qubits + 1}}}$"
    for i in range(num_data_qubits + num_z_checks, num_data_qubits + num_z_checks + num_x_checks):
        labels[i] = f"$X_{{{i - (num_data_qubits + num_z_checks) + 1}}}$"

    G = nx.relabel_nodes(G, labels)

    return G


def classical_pcm(clist: list) -> np.ndarray:
    num_bits = clist.count("B")
    H = []
    for i in range(len(clist)):
        if clist[i] == "C":
            peak_i = i + 1
            one_hot_vec = np.zeros(num_bits)
            while peak_i < len(clist) and type(clist[peak_i]) != str:
                one_hot_vec[clist[peak_i]] = 1
                peak_i += 1
            H.append(one_hot_vec)

    return np.array(H, dtype=int)


# TODO: Fix this! This is supposed to take the new position representation (list).
def intersecting_edges(
    adjacency_matrix: np.ndarray, positions: list[tuple[float, float]]
) -> set[frozenset[tuple[float, float]]]:
    # Generate list of edges.
    edges = []
    for i in range(adjacency_matrix.shape[0]):
        for j in range(i + 1, adjacency_matrix.shape[0]):
            if adjacency_matrix[i, j] == 1:
                edges.append((i, j))

    # Function to check if lines intersect.
    def ccw(A, B, C):
        return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])

    def do_lines_intersect(line1, line2):
        A, B = line1
        C, D = line2
        return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)

    # Find all sets of two edges that intersect.
    intersecting_edges = set()
    for edge1, edge2 in combinations(edges, 2):
        line1 = (positions[edge1[0]], positions[edge1[1]])
        line2 = (positions[edge2[0]], positions[edge2[1]])
        if do_lines_intersect(line1, line2):
            intersecting_edges.add(frozenset((edge1, edge2)))

    # Remove pairs where the edges share a node, because they can't intersect in a plane graph.
    non_intersecting_pairs = set()
    for pair in intersecting_edges:
        edge1, edge2 = pair
        if len(set(edge1) & set(edge2)) != 0:
            non_intersecting_pairs.add(pair)
    intersecting_edges -= non_intersecting_pairs

    return intersecting_edges


def strip(s: str) -> int:
    s_int = ""
    for c in s:
        if c.isdigit():
            s_int += c

    return int(s_int)
